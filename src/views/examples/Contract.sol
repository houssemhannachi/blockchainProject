// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;


contract SupplyChain{
    //define contract owner
    address ContractOwner;

    

    // Define enum 'State' with the following values:
    enum State {
        ProduceByFarmer, // 0
        ForSaleByFarmer, // 1
        PurchasedByDistributor, // 2
        ShippedByFarmer, // 3
        ReceivedByDistributor, // 4
        ProcessedByDistributor, // 5
        PackageByDistributor, // 6
        ForSaleByDistributor, // 7
        PurchasedByRetailer, // 8
        ShippedByDistributor, // 9
        ReceivedByRetailer, // 10
        ForSaleByRetailer, // 11
        PurchasedByConsumer // 12
    }

    State constant defaultState = State.ProduceByFarmer;

    // Define a struct 'Item' with the following fields:
    struct Item {
        uint256 productNumber;
        uint256 productCode; // Universal Product Code (productCode), generated by the Farmer, goes on the package, can be verified by the Consumer
        address ownerID; // Metamask-Ethereum address of the current owner as the product moves through 8 stages
        address originFarmerID; // Metamask-Ethereum address of the Farmer // ADDED PAYABLE
        string originFarmName; // Farmer Name
        string originFarmInformation; // Farmer Information
        string originFarmLatitude; // Farm Latitude
        string originFarmLongitude; // Farm Longitude
        string productNotes; // Product Notes
        uint256 productDate; // Product Date NOTE: MIGHT NEED TO CHANGE type
        uint256 productPrice; // Product Price
        State itemState; // Product State as represented in the enum above
        address distributorID; // Metamask-Ethereum address of the Distributor
        address retailerID; // Metamask-Ethereum address of the Retailer
        address consumerID; // Metamask-Ethereum address of the Consumer // ADDED payable
    }



    // Block number stuct
    struct Txblocks {
        uint256 FTD; // blockfarmerToDistributor
        uint256 DTR; // blockDistributorToRetailer
        uint256 RTC; // blockRetailerToConsumer
    }

    // Define a public mapping 'itemsHistory' that maps the productCode to an array of TxHash,
    // that track its journey through the supply chain -- to be sent from DApp.
    mapping(uint256 => Txblocks) itemsHistory;

    //define mapping for farmers
    mapping(address=>bool) farmers;

    //define mapping for Distributors
    mapping(address=>bool) Distributors;

    //define mapping for retailers 
    mapping(address=>bool) retailers;

    //define mapping for consumers;
    mapping(address=>bool) consumers;

    //define mapping for Items 
    mapping(uint256=>Item) items;
    mapping(uint256=>Item) allItems;

    uint64 numberOfItems;

    event ProduceByFarmer(uint256 productCode); //1
    event ForSaleByFarmer(uint256 productCode); //2
    event PurchasedByDistributor(uint256 productCode); //3
    event ShippedByFarmer(uint256 productCode); //4
    event ReceivedByDistributor(uint256 productCode); //5
    event ProcessedByDistributor(uint256 productCode); //6
    event PackagedByDistributor(uint256 productCode); //7
    event ForSaleByDistributor(uint256 productCode); //8
    event PurchasedByRetailer(uint256 productCode); //9
    event ShippedByDistributor(uint256 productCode); //10
    event ReceivedByRetailer(uint256 productCode); //11
    event ForSaleByRetailer(uint256 productCode); //12
    event PurchasedByConsumer(uint256 productCode); //13

    // Define a modifer that checks to see if msg.sender == owner of the contract
    modifier only_Owner() {
        require(msg.sender == ContractOwner,"You are not an owner");
        _;
    }

    //Item State Modifiers
    modifier producedByFarmer(uint256 _productCode) {
        require(items[_productCode].itemState == State.ProduceByFarmer,"product is not produced ");
        _;
    }
    modifier forSaleByFarmer(uint256 _productCode) {
        require(items[_productCode].itemState == State.ForSaleByFarmer,"product is not for sale yet");
        _;
    }

    modifier purchasedByDistributor(uint256 _productCode) {
        require(items[_productCode].itemState == State.PurchasedByDistributor,"product is not Purchased by distributors yet");
        _;
    }

    modifier shippedByFarmer(uint256 _productCode) {
        require(items[_productCode].itemState == State.ShippedByFarmer,"product is not shipped by farmer yet");
        _;
    }

    modifier receivedByDistributor(uint256 _productCode) {
        require(items[_productCode].itemState == State.ReceivedByDistributor,"product not received by Distributor yet");
        _;
    }

    modifier processByDistributor(uint256 _productCode) {
        require(items[_productCode].itemState == State.ProcessedByDistributor,"product not processed by distributor yet");
        _;
    }

    modifier packagedByDistributor(uint256 _productCode) {
        require(items[_productCode].itemState == State.PackageByDistributor,"product not packaged by distributor yet");
        _;
    }

    modifier forSaleByDistributor(uint256 _productCode) {
        require(items[_productCode].itemState == State.ForSaleByDistributor,"product is not for sale by distributor");
        _;
    }

    modifier shippedByDistributor(uint256 _productCode) {
        require(items[_productCode].itemState == State.ShippedByDistributor,"product is not shipped yet by distributor");
        _;
    }

    modifier purchasedByRetailer(uint256 _productCode) {
        require(items[_productCode].itemState == State.PurchasedByRetailer,"product is not purchased by retailer yet");
        _;
    }

    modifier receivedByRetailer(uint256 _productCode) {
        require(items[_productCode].itemState == State.ReceivedByRetailer,"product is not receivedByRetailer yet");
        _;
    }

    modifier forSaleByRetailer(uint256 _productCode) {
        require(items[_productCode].itemState == State.ForSaleByRetailer,"product is not for sale by Retailer yet");
        _;
    }

    modifier purchasedByConsumer(uint256 _productCode) {
        require(items[_productCode].itemState == State.PurchasedByConsumer,"product is not purchased by consumer yet");
        _;
    }

    //Check Roles
    modifier onlyFarmer(){
        require(farmers[msg.sender]==true,"you are not a farmer");
        _;
    }
    modifier onlyDistributor(){
        require(Distributors[msg.sender]==true,"you are not a distibutor");
        _;
    }
    modifier onlyRetailer(){
        require(retailers[msg.sender]==true,"you are not a retailer");
        _;
    }
    modifier onlyConsumer(){
        require(consumers[msg.sender]==true,"you are not a consumer");
        _;
    }

    //Check if caller is recent owner of item
    modifier verifyCaller(address _itemowner){
        require(msg.sender==_itemowner,"you are not the owner");
        _;
    }

    //Check if amount sent is enough to purchase Item
    modifier paidEnough(uint256 amount){
        require((amount*1 ether)<= msg.value,"you have not paid enough");
        _;
    }

    constructor(){
        ContractOwner=msg.sender;
    }

    //add farmer
    function add_farmer(address _farmerAddress) public only_Owner(){
        farmers[_farmerAddress]= true;

    }

    //add consumer
    function add_consumer(address _consumerAddress) public {
        consumers[_consumerAddress]= true;

    }

    //add retailer
    function add_retailer(address _retailerAddress) public {
        retailers[_retailerAddress]= true;

    }

    //add Distributor
    function add_destributer(address _destriuterAddress) public {
        Distributors[_destriuterAddress]= true;
        

    }

    //check user
    function check_user() public view  returns (uint8){
        if(farmers[msg.sender]==true){
            return 1;
        }
        else if (Distributors[msg.sender]==true){
            return 2;
        }
        else if (retailers[msg.sender]==true){
            return 3;
        }
        else if (consumers[msg.sender]==true){
            return 4;
        }
        else{
            return 0;
        }
    }

     /*
 1st step in supplychain
 Allows farmer to create cheese
*/
    function produceItemByFarmer(
        uint256 _productCode,
        string memory _originFarmName,
        string memory _originFarmInformation,
        string memory _originFarmLatitude,
        string memory _originFarmLongitude,
        string memory _productNotes,
        uint256 _price
    )
        public

        onlyFarmer
        
    {
        address distributorID; // Empty distributorID address
        address retailerID; // Empty retailerID address
        address consumerID; // Empty consumerID address
        Item memory newProduce; // Create a new struct Item in memory
        newProduce.productNumber=numberOfItems;
        newProduce.productCode = _productCode; // Universal Product Code (productCode), generated by the Farmer, goes on the package, can be verified by the Consumer
        newProduce.ownerID = msg.sender; // Metamask-Ethereum address of the current owner as the product moves through 8 stages
        newProduce.originFarmerID = msg.sender; // Metamask-Ethereum address of the Farmer
        newProduce.originFarmName = _originFarmName; // Farmer Name
        newProduce.originFarmInformation = _originFarmInformation; // Farmer Information
        newProduce.originFarmLatitude = _originFarmLatitude; // Farm Latitude
        newProduce.originFarmLongitude = _originFarmLongitude; // Farm Longitude
        newProduce.productNotes = _productNotes; // Product Notes
        newProduce.productPrice = _price; // Product Price
        newProduce.productDate = block.timestamp;
        newProduce.itemState = defaultState; // Product State as represented in the enum above
        newProduce.distributorID = distributorID; // Metamask-Ethereum address of the Distributor
        newProduce.retailerID = retailerID; // Metamask-Ethereum address of the Retailer
        newProduce.consumerID = consumerID; // Metamask-Ethereum address of the Consumer // ADDED payable
        items[_productCode] = newProduce; // Add newProduce to items struct by productCode
        allItems[numberOfItems]=newProduce;
        numberOfItems++;
        uint256 placeholder; // Block number place holder
        Txblocks memory txBlock; // create new txBlock struct
        txBlock.FTD = placeholder; // assign placeholder values
        txBlock.DTR = placeholder;
        txBlock.RTC = placeholder;
        itemsHistory[_productCode] = txBlock; // add txBlock to itemsHistory mapping by productCode



        // Emit the appropriate event
        emit ProduceByFarmer(_productCode);
    }

     /*
2nd step in supplychain
Allows farmer to sell cheese
*/
    function sellItemByFarmer(uint256 _productCode, uint256 _price)
        public
        onlyFarmer
        producedByFarmer(_productCode)
        verifyCaller(items[_productCode].ownerID)
    {
        items[_productCode].itemState = State.ForSaleByFarmer;
        items[_productCode].productPrice = _price;
        allItems[ items[_productCode].productNumber].itemState = State.ForSaleByFarmer;
        allItems[ items[_productCode].productNumber].productPrice=_price;
        emit ForSaleByFarmer(_productCode);
    }

    /*
3rd step in supplychain
Allows distributor to purchase cheese
*/
    function purchaseItemByDistributor(uint256 _productCode)
        public
        payable
        onlyDistributor 
        forSaleByFarmer(_productCode) 
        paidEnough(items[_productCode].productPrice) 
        {
        address payable reciever =_make_payable(items[_productCode].originFarmerID);
        reciever.transfer(msg.value);
        items[_productCode].ownerID =msg.sender; // update owner
        items[_productCode].distributorID =msg.sender; // update distributor
        items[_productCode].itemState = State.PurchasedByDistributor; // update state
        allItems[ items[_productCode].productNumber].ownerID =msg.sender;
        allItems[ items[_productCode].productNumber].distributorID =msg.sender;
        allItems[ items[_productCode].productNumber].itemState = State.PurchasedByDistributor;
        itemsHistory[_productCode].FTD = block.number; // add block number
        
        emit PurchasedByDistributor(_productCode);
    }

        /*
  4th step in supplychain
  Allows farmer to ship cheese purchased by distributor
  */
    function shippedItemByFarmer(uint256 _productCode)
        public
        payable
        onlyFarmer
        purchasedByDistributor(_productCode)
        verifyCaller(items[_productCode].originFarmerID)
    {
        items[_productCode].itemState = State.ShippedByFarmer; // update state
        allItems[ items[_productCode].productNumber].itemState= State.ShippedByFarmer;
        emit ShippedByFarmer(_productCode);
    }
        /*
  5th step in supplychain
  Allows distributor to receive cheese
  */
    function receivedItemByDistributor(uint256 _productCode)
        public
        onlyDistributor 
        shippedByFarmer(_productCode)
        verifyCaller(items[_productCode].ownerID) 
    {
        items[_productCode].itemState = State.ReceivedByDistributor; // update state
         allItems[ items[_productCode].productNumber].itemState= State.ReceivedByDistributor;
        emit ReceivedByDistributor(_productCode);
    }
        /*
  6th step in supplychain
  Allows distributor to process cheese
  */
    function processedItemByDistributor(uint256 _productCode)
        public
        onlyDistributor 
        receivedByDistributor(_productCode)
        verifyCaller(items[_productCode].ownerID)
    {
        items[_productCode].itemState = State.ProcessedByDistributor; // update state
        allItems[ items[_productCode].productNumber].itemState= State.ProcessedByDistributor;
        emit ProcessedByDistributor(_productCode);
    }
        /*
  7th step in supplychain
  Allows distributor to package cheese
  */
    function packageItemByDistributor(uint256 _productCode)
        public
        onlyDistributor 
        processByDistributor(_productCode)
        verifyCaller(items[_productCode].ownerID)
    {
        items[_productCode].itemState = State.PackageByDistributor;
         allItems[ items[_productCode].productNumber].itemState= State.PackageByDistributor;
        emit PackagedByDistributor(_productCode);
    }
       /*
  8th step in supplychain
  Allows distributor to sell cheese
  */
    function sellItemByDistributor(uint256 _productCode, uint256 _price)
        public
        onlyDistributor
        packagedByDistributor(_productCode)
        verifyCaller(items[_productCode].ownerID)
    {
        items[_productCode].itemState = State.ForSaleByDistributor;
        items[_productCode].productPrice = _price;
         allItems[ items[_productCode].productNumber].itemState= State.ForSaleByDistributor;
          allItems[ items[_productCode].productNumber].productPrice = _price;
        emit ForSaleByDistributor(_productCode);
    }

    /*
  9th step in supplychain
  Allows retailer to purchase cheese
  */
    function purchaseItemByRetailer(uint256 _productCode)
        public
        payable
        onlyRetailer // check msg.sender belongs to RetailerRole
        forSaleByDistributor(_productCode)
        paidEnough(items[_productCode].productPrice)
    {
        address payable reciever =_make_payable(items[_productCode].distributorID);
        reciever.transfer(msg.value);
        items[_productCode].ownerID = msg.sender;
        items[_productCode].retailerID = msg.sender;
        items[_productCode].itemState = State.PurchasedByRetailer;
        allItems[ items[_productCode].productNumber].ownerID== msg.sender;
        allItems[ items[_productCode].productNumber].retailerID== msg.sender;
        allItems[ items[_productCode].productNumber].itemState= State.PurchasedByRetailer;

        itemsHistory[_productCode].DTR = block.number;
        emit PurchasedByRetailer(_productCode);
    }

    /*
  10th step in supplychain
  Allows Distributor to
  */
    function shippedItemByDistributor(uint256 _productCode)
        public
        onlyDistributor // check msg.sender belongs to DistributorRole
        purchasedByRetailer(_productCode)
        verifyCaller(items[_productCode].distributorID) // check msg.sender is distributorID
    {
        items[_productCode].itemState = State.ShippedByDistributor;
         allItems[ items[_productCode].productNumber].itemState= State.ShippedByDistributor;
        emit ShippedByDistributor(_productCode);
    }

    /*
  11th step in supplychain
  */
    function receivedItemByRetailer(uint256 _productCode)
        public
        onlyRetailer // check msg.sender belongs to RetailerRole
        shippedByDistributor(_productCode)
        verifyCaller(items[_productCode].ownerID) // check msg.sender is ownerID
    {
        items[_productCode].itemState = State.ReceivedByRetailer;
         allItems[ items[_productCode].productNumber].itemState= State.ReceivedByRetailer;
        emit ReceivedByRetailer(_productCode);
    }

    /*
  12th step in supplychain
  */
    function sellItemByRetailer(uint256 _productCode, uint256 _price)
        public
        onlyRetailer // check msg.sender belongs to RetailerRole
        receivedByRetailer(_productCode)
        verifyCaller(items[_productCode].ownerID) // check msg.sender is ownerID
    {
        items[_productCode].itemState = State.ForSaleByRetailer;
        items[_productCode].productPrice = _price;
         allItems[ items[_productCode].productNumber].itemState= State.ForSaleByRetailer;
          allItems[ items[_productCode].productNumber].productPrice= _price;
        emit ForSaleByRetailer(_productCode);
    }

    /*
  13th step in supplychain
  */
    function purchaseItemByConsumer(uint256 _productCode)
        public
        payable
        onlyConsumer // check msg.sender belongs to ConsumerRole
        forSaleByRetailer(_productCode)
        paidEnough(items[_productCode].productPrice)
    {
        address payable reciever =_make_payable(items[_productCode].retailerID);
        reciever.transfer(msg.value);
        items[_productCode].consumerID = msg.sender;
        items[_productCode].ownerID = msg.sender;
        items[_productCode].itemState = State.PurchasedByConsumer;
         allItems[ items[_productCode].productNumber].consumerID = msg.sender;
          allItems[ items[_productCode].productNumber].ownerID = msg.sender;
           allItems[ items[_productCode].productNumber].itemState= State.PurchasedByConsumer;


        itemsHistory[_productCode].RTC = block.number;
        emit PurchasedByConsumer(_productCode);
    }




// allows you to convert an address into a payable address
    function _make_payable(address x) internal pure returns (address payable) {
        return payable(address(uint160(x)));
    }


    function get_all_items() public view returns (Item[] memory products){
        products = new Item[](numberOfItems);
        for(uint256 index = 0; index < numberOfItems; index++){
            products[index]=allItems[index];

        }
    }






    


}